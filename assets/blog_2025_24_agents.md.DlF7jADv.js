import{_ as a,c as i,o as n,a9 as t}from"./chunks/framework.DsVI9alt.js";const g=JSON.parse('{"title":"Agents.md 是什么","description":"深入解析 AGENTS.md 文件在 AI 编程工具生态中的作用，了解它与 MCP 协议的区别，以及如何为 AI 代理提供结构化项目上下文。","frontmatter":{"title":"Agents.md 是什么","description":"深入解析 AGENTS.md 文件在 AI 编程工具生态中的作用，了解它与 MCP 协议的区别，以及如何为 AI 代理提供结构化项目上下文。","author":"mcell","tags":["AI 编程","AGENTS.md","MCP","AI 代理","代码工具"],"keywords":["AGENTS.md","AI 编程工具","MCP 协议","AI 代理上下文","代码仓库配置","AI 驱动开发","项目上下文文件","AI 开发工具"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/24_agents"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/24_agents"}]]},"headers":[],"relativePath":"blog/2025/24_agents.md","filePath":"blog/2025/24_agents.md","lastUpdated":1759585178000}'),e={name:"blog/2025/24_agents.md"};function l(p,s,o,h,d,r){return n(),i("div",null,s[0]||(s[0]=[t(`<p><img src="https://stack-mcell.tos-cn-shanghai.volces.com/056.png" alt="056.png" loading="lazy"></p><h1 id="agents-md-又是什么" tabindex="-1">Agents.md 又是什么 <a class="header-anchor" href="#agents-md-又是什么" aria-label="Permalink to &quot;Agents.md 又是什么&quot;">​</a></h1><p>最近，如果你关注 AI 编程工具的生态，可能会注意到两个新名词频繁出现：<strong>MCP</strong> 和 <strong>Agents.md</strong>。</p><p>MCP（Model Context Protocol）是为大语言模型（LLM）提供标准化上下文接入方式的协议，类似于让 LLM 能“看懂”外部工具、数据源和环境的一种通用语言。它试图解决的问题是：<strong>如何让不同的 AI 工具以统一方式向模型提供上下文？</strong></p><p>而 Agents.md，则看起来更“朴素”——它只是一个 Markdown 文件，放在你的代码仓库根目录下，内容通常是：</p><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## Setup commands</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Install deps: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm install\`</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Start dev server: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm dev\`</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Run tests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm test\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## Code style</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TypeScript strict mode</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Single quotes, no semicolons</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Use functional patterns where possible</span></span></code></pre></div><p>乍一看，这不就是 README 的一部分吗？为什么还要单独搞一个 <code>AGENTS.md</code>？</p><h2 id="人类看-readme-agent-看-agents-md" tabindex="-1">人类看 README，Agent 看 AGENTS.md <a class="header-anchor" href="#人类看-readme-agent-看-agents-md" aria-label="Permalink to &quot;人类看 README，Agent 看 AGENTS.md&quot;">​</a></h2><p>关键区别在于<strong>受众不同</strong>。</p><ul><li><strong>README.md</strong> 是写给人看的：项目简介、快速上手、贡献指南、社区链接……它追求简洁、友好、有吸引力。</li><li><strong>AGENTS.md</strong> 是写给 AI 编程代理（coding agent）看的：构建命令、测试流程、代码风格、依赖结构、CI 规则……它追求<strong>精确、可执行、无歧义</strong>。</li></ul><p><img src="https://stack-mcell.tos-cn-shanghai.volces.com/057.png" alt="057.png" loading="lazy"></p><p>举个例子：人类看到“请先安装依赖”就懂了；但 AI 代理需要明确知道是 <code>npm install</code>、<code>yarn install</code> 还是 <code>pnpm install</code>。一个错字，整个自动化流程就可能崩掉。</p><p>所以，AGENTS.md 的出现，不是为了取代 README，而是<strong>为 AI 代理提供一个专属的、结构化的操作手册</strong>。</p><h2 id="为什么不能直接用-claude-md" tabindex="-1">为什么不能直接用 CLAUDE.md？ <a class="header-anchor" href="#为什么不能直接用-claude-md" aria-label="Permalink to &quot;为什么不能直接用 CLAUDE.md？&quot;">​</a></h2><p>确实，像 Claude Code Cli 这样的工具已经支持通过 <code>CLAUDE.md</code> 提供项目上下文。但这带来一个问题：<strong>碎片化</strong>。</p><ul><li>Claude 用 <code>CLAUDE.md</code></li><li>Cursor 可能用 <code>.cursor/config.md</code></li><li>GitHub Copilot 实验性功能可能用 <code>.github/copilot.md</code></li><li>你自研的 agent 又定义了自己的格式……</li></ul><p>每个工具一套规则，开发者疲于维护多个“上下文文件”，而项目仓库也变得杂乱。</p><p><strong>AGENTS.md 的野心，是成为一个开放、通用、无厂商锁定的标准</strong>——就像 <code>package.json</code> 之于 Node.js，<code>.gitignore</code> 之于 Git。</p><p>它不隶属于 OpenAI、Anthropic 或 Google，而是由社区共建（包括 OpenAI Codex、Cursor、Google Jules 等团队参与推动）。目前已有超过 <a href="https://github.com/search?q=path%3AAGENTS.md&amp;type=code" target="_blank" rel="noreferrer">41,000</a> 个开源项目采用。</p><h2 id="agents-md-和-mcp-互补而非竞争" tabindex="-1">AGENTS.md 和 MCP：互补而非竞争 <a class="header-anchor" href="#agents-md-和-mcp-互补而非竞争" aria-label="Permalink to &quot;AGENTS.md 和 MCP：互补而非竞争&quot;">​</a></h2><p>你可能会问：既然有了 MCP 这种“协议级”标准，还需要 AGENTS.md 这种“文件级”约定吗？</p><p>答案是：<strong>它们在不同层次工作，互为补充</strong>。</p><ul><li><strong>MCP</strong> 是运行时协议：定义 AI 如何与工具、API、数据库等<strong>动态交互</strong>。比如 Github 提交一个 PR。</li><li><strong>AGENTS.md</strong> 是静态上下文：告诉 AI “在这个项目里，你应该怎么做事”。比如“用 pnpm 而不是 npm”、“测试命令是 <code>pnpm test</code>”。</li></ul><p>可以这样类比：</p><ul><li>MCP 是“操作系统 API”，让程序能调用硬件；</li><li>AGENTS.md 是“项目 README for machines”，让 AI 能理解项目约定。</li></ul><p>一个管“能力接入”，一个管“行为规范”。</p><h2 id="写-agents-md-其实是在-教-ai-做人" tabindex="-1">写 AGENTS.md，其实是在“教 AI 做人” <a class="header-anchor" href="#写-agents-md-其实是在-教-ai-做人" aria-label="Permalink to &quot;写 AGENTS.md，其实是在“教 AI 做人”&quot;">​</a></h2><p>AGENTS.md 的真正价值，不在于技术实现，而在于<strong>把隐性知识显性化</strong>。</p><p>很多项目中，构建流程、测试策略、代码风格其实只存在于老员工的脑子里，或者散落在 CI 配置、PR 模板、Slack 聊天记录里。新人（无论是人类还是 AI）进来都要“踩坑学习”。</p><p>而 AGENTS.md 强制你把这些规则写下来，形成一份<strong>可被机器理解的契约</strong>。</p><p>更妙的是，它还能嵌套：在 monorepo 中，每个子包都可以有自己的 <code>AGENTS.md</code>，实现上下文隔离。</p><h2 id="未来-ai-时代的-项目规范" tabindex="-1">未来：AI 时代的“项目规范” <a class="header-anchor" href="#未来-ai-时代的-项目规范" aria-label="Permalink to &quot;未来：AI 时代的“项目规范”&quot;">​</a></h2><p>AGENTS.md 的愿景，是成为每个代码仓库的“标配文件”——就像 LICENSE、README、package.json 一样自然。</p><p>它不炫技，不复杂，只是一个简单的 Markdown 文件。但正是这种简单，让它有可能被广泛采纳。</p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>技术演进常常如此：先有混乱的实践，再有统一的规范。</p><p>MCP 解决了“AI 如何连接世界”的问题，<br> AGENTS.md 则解决“AI 如何理解你的项目”的问题。</p><p>一个向外连接，一个向内约定。</p><p>当这两个方向都逐渐标准化，AI 编程代理才能真正从“玩具工程”变成“生产力工具”。</p><p>而作为开发者，我们能做的，就是在你的下一个有 AI 参与开发的项目里，加一个 <code>AGENTS.md</code>。</p><p>不需要多复杂，只要写清楚三件事：</p><ol><li>怎么跑起来？</li><li>怎么测正确？</li><li>代码怎么写？</li></ol><p>这就够了。</p><blockquote><p><strong>附：AGENTS.md 示例模板</strong></p><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;"># AGENTS.md</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## Setup</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Install: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm install\`</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Dev: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm dev\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## Testing</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Run all tests: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm test\`</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Lint: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\`pnpm lint\`</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">## Code Style</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TypeScript with strict mode</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Single quotes, no semicolons</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Prefer functional over class-based components</span></span></code></pre></div></blockquote><p>（完）</p>`,45)]))}const c=a(e,[["render",l]]);export{g as __pageData,c as default};
