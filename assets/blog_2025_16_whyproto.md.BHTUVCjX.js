import{_ as i,c as a,o as n,a2 as e}from"./chunks/framework.CGIWSPU7.js";const g=JSON.parse('{"title":"为什么我们需要 .proto 文件：解决团队协作与跨语言通信难题","description":"深入理解 Protocol Buffers 的核心价值，从痛点分析到实战应用，掌握 .proto 文件在多语言开发中的关键作用","frontmatter":{"title":"为什么我们需要 .proto 文件：解决团队协作与跨语言通信难题","description":"深入理解 Protocol Buffers 的核心价值，从痛点分析到实战应用，掌握 .proto 文件在多语言开发中的关键作用","date":"2025-01-16T00:00:00.000Z","tags":["Protocol Buffers","gRPC","微服务","跨语言通信","API 设计"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/16_whyproto"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/16_whyproto"}]]},"headers":[],"relativePath":"blog/2025/16_whyproto.md","filePath":"blog/2025/16_whyproto.md","lastUpdated":1755147736000}'),l={name:"blog/2025/16_whyproto.md"};function p(t,s,h,r,k,o){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="为什么我们需要-proto-文件" tabindex="-1">为什么我们需要 <code>.proto</code> 文件 <a class="header-anchor" href="#为什么我们需要-proto-文件" aria-label="Permalink to &quot;为什么我们需要 \`.proto\` 文件&quot;">​</a></h1><h2 id="🤷‍♀️-为什么我们需要-proto-文件" tabindex="-1">🤷‍♀️ 为什么我们需要 <code>.proto</code> 文件？ <a class="header-anchor" href="#🤷‍♀️-为什么我们需要-proto-文件" aria-label="Permalink to &quot;🤷‍♀️ 为什么我们需要 \`.proto\` 文件？&quot;">​</a></h2><p>你是否在开发中遇到过这些痛点？</p><ul><li><p>格式混乱，沟通成本爆炸 ：团队里，后端用 Go 写接口，前端用 React，移动端用 Java/Kotlin。大家都在用 JSON/REST，接口文档写了两份，甚至三份，而且谁来维护？</p><p>举个例子，后端定义了一个 &quot;User&quot; 模型，字段是 user: { name: string, age: number }，而前端同事可能误以为是 user: { username: string, age: string }。结果呢？联调半天，最后才发现是字段名或类型对不上。这不就是典型的&quot;接口谁写谁崩&quot;现场吗？</p></li><li><p>JSON 性能，高并发下的&quot;鸡肋&quot; 🐢：JSON 虽然人类可读性好，但在机器之间传输时却显得过于冗长。 看看下面这个 JSON 例子：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123456&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mCell&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;tags&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;go&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>每次传输，你都得附带像 <code>&quot;id&quot;</code>, <code>&quot;name&quot;</code>, <code>&quot;tags&quot;</code> 这样的字符串字段名。对于稍微高并发的场景，或者数据量稍大，这种额外的开销就让性能变得非常&quot;鸡肋&quot;。相比之下，<code>.proto</code> 文件编译后的<strong>二进制序列化</strong>，性能差距不言而喻。</p></li><li><p><strong>多语言互通的&quot;噩梦&quot;</strong> ：Go 后端写好的数据结构，如果你的 Node.js 服务、Java 微服务、Python 数据分析脚本都需要使用它，那不好意思，每个语言都得把这些数据结构重新定义一遍。这不仅重复劳动，还容易引入不一致的 bug。</p></li></ul><p>为了解决这些普遍存在的痛点， <strong><code>.proto</code> 文件应运而生</strong>：</p><p><code>proto</code> 诞生于 google， 是为了解决多个服务之间混乱通信而设计的一套标准格式——<strong>Protocol Buffers</strong>。它已经在 Google 内部被使用了十几年，从早期的广告系统到后来的搜索、地图服务，<code>.proto</code> 是他们确保数据结构统一、跨语言 RPC 正常运行的&quot;<strong>协议基石</strong>&quot;。</p><h3 id="proto-文件带来的核心优势" tabindex="-1"><code>.proto</code> 文件带来的核心优势： <a class="header-anchor" href="#proto-文件带来的核心优势" aria-label="Permalink to &quot;\`.proto\` 文件带来的核心优势：&quot;">​</a></h3><ol><li><strong>统一定义，一处修改，处处生效</strong>：一份 <code>.proto</code> 文件，就是团队的唯一数据契约。多语言共享，无论前端、后端、移动端，都能基于这份定义生成各自语言的代码，字段很统一；</li><li><strong>高效序列化，又小又快</strong>：Protocol Buffers 采用<strong>二进制格式</strong>进行数据序列化。这意味着数据传输时，比 JSON 更小巧、解析速度更快，特别适合用于 RPC（远程过程调用）、消息队列、微服务之间的通信等对性能要求较高的场景。</li><li><strong>版本兼容，优雅演进</strong>：<code>.proto</code> 文件在设计时就考虑到了版本兼容性。你可以安全地在 <code>message</code> 中增加新字段，而不会影响到使用旧版本定义的服务。当然，删除字段或修改字段类型需要遵循一定的规则，而每个字段的**标签编号（Field Number）**就是确保兼容性的&quot;定海神针&quot;，它能管住你乱改，避免不必要的兼容性问题。</li></ol><p>大白话讲，<code>.proto</code> 文件让你只需编写一次数据模型定义，然后就能通过编译工具，自动生成支持 Go、Node.js、Java 等多种语言的结构体代码。这些代码还自带高效的二进制序列化和反序列化能力，并且提供了清晰的接口契约，大大节省了开发时间，提升了系统可靠性。</p><h2 id="📖-核心语法格式-proto3-入门" tabindex="-1">📖 核心语法格式（Proto3 入门） <a class="header-anchor" href="#📖-核心语法格式-proto3-入门" aria-label="Permalink to &quot;📖 核心语法格式（Proto3 入门）&quot;">​</a></h2><p>让我们来看看一个 <code>.proto</code> 文件的基本结构和核心语法，这里我们以主流的 <strong>Proto3</strong> 版本为例：</p><div class="language-proto vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">syntax</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;proto3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指明使用 Proto3 语法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your.package.name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类似 Java/Go 中的包名或命名空间，用于避免命名冲突</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 消息定义（Message）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MessageName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用来定义你想要传递的数据结构，相当于 Go 的 struct 或 Java 的 class</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;type&gt; &lt;field_name&gt; = &lt;number&gt;; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;number&gt; 是字段标签，一个唯一的整数，千万别随意改动！</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="关键元素解析" tabindex="-1">关键元素解析： <a class="header-anchor" href="#关键元素解析" aria-label="Permalink to &quot;关键元素解析：&quot;">​</a></h3><ul><li><strong>类型支持</strong>：Protocol Buffers 支持丰富的标量数据类型，包括 <code>int32</code>、<code>int64</code>、<code>float</code>、<code>double</code>、<code>string</code>、<code>bool</code>、<code>bytes</code>。此外，你还可以嵌套自定义的 <code>message</code> 类型来构建复杂的数据结构。</li><li><strong>标签编号（Field Tag Numbers）</strong> ：<code>= 1, = 2...</code> 后面的数字是每个字段的唯一标签。它们在数据进行二进制编码和解码时用于识别字段，并且在版本兼容性方面起着至关重要的作用。一旦给一个字段分配了标签编号，就不要轻易更改它，即使删除了字段，这个标签编号也应该保留，以防将来复用导致兼容性问题。</li><li><strong><code>repeated</code></strong>：如果你需要定义一个可以包含零个或多个元素的列表或数组，就使用 <code>repeated</code> 关键字。例如，<code>repeated string tags = 5;</code> 表示 <code>tags</code> 是一个字符串列表。</li><li><strong><code>map&lt;key_type, value_type&gt;</code></strong> ：这个关键字允许你定义字典（Map）类型的数据结构。比如，<code>map&lt;string, string&gt; attributes = 6;</code> 可以用来表示键值对属性。</li></ul><h2 id="🌰-举个栗子-用户模型定义" tabindex="-1">🌰 举个栗子：用户模型定义 <a class="header-anchor" href="#🌰-举个栗子-用户模型定义" aria-label="Permalink to &quot;🌰 举个栗子：用户模型定义&quot;">​</a></h2><p>下面，我们就用 <code>.proto</code> 来定义一个常见的&quot;用户模型&quot;，并体会一下它的简洁与直观：</p><div class="language-proto vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">proto</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">syntax</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;proto3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义这个 User 消息所在的包名</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户基础信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户唯一标识符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户昵称</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> email </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 邮箱地址</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 年龄</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  repeated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用户标签数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>简单明了，对吧？</p><ul><li><code>message User</code>: 定义了一个名为 <code>User</code> 的数据结构。</li><li><code>string id = 1</code>: 定义了一个字符串类型的字段 <code>id</code>，其标签编号是 <code>1</code>。</li><li><code>repeated string tags = 5</code>: 定义了一个字符串类型的列表 <code>tags</code>，其标签编号是 <code>5</code>。</li></ul><h2 id="🚀-node-js-一键生成-快乐使用" tabindex="-1">🚀 Node.js：一键生成，快乐使用 <a class="header-anchor" href="#🚀-node-js-一键生成-快乐使用" aria-label="Permalink to &quot;🚀 Node.js：一键生成，快乐使用&quot;">​</a></h2><p>定义好 <code>.proto</code> 文件后，接下来就是编译生成各语言代码的&quot;魔法&quot;时刻了。</p><p>首先，你需要安装必要的工具：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> grpc-tools</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> grpc_tools_node_protoc_ts</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后，使用 <code>protoc</code> 命令来生成 JavaScript（以及 TypeScript 类型定义）文件：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">grpc_tools_node_protoc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --js_out=import_style=commonjs,binary:./generated</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --grpc_out=grpc_js:./generated</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --proto_path=.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  user.proto</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>执行完上述命令后，你会在 <code>./generated</code> 文件夹中看到生成的代码，通常包括 <code>user_pb.js</code>（包含数据结构定义）以及 <code>user_grpc_pb.js</code>（如果你在 <code>.proto</code> 中定义了 gRPC 服务）。</p><p>来看看如何在 Node.js 客户端中使用这些生成的代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./generated/user_pb&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入 User 消息定义</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果你的 .proto 文件中定义了 gRPC 服务，你还会用到下面这行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const { UserServiceClient } = require(&#39;./generated/user_grpc_pb&#39;);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const grpc = require(&#39;@grpc/grpc-js&#39;);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 如果是 gRPC 客户端，需要引入 grpc 库</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const client = new UserServiceClient(&#39;localhost:50051&#39;, grpc.credentials.createInsecure());</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // gRPC 客户端实例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构造一个 User 实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mCell&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setEmail</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mcell@example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAge</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;golang&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加标签到 repeated 字段</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addTags</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;typescript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;生成的 User 对象 (Node.js):&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 你也可以将对象序列化为二进制数据，用于网络传输或存储</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const bytes = user.serializeBinary();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(&#39;序列化后的二进制数据:&#39;, bytes);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同样，也可以从二进制数据反序列化回对象</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// const decodedUser = User.deserializeBinary(bytes);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(&#39;反序列化后的 User 对象:&#39;, decodedUser.toObject());</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>如此，通过简单的几行代码，你就实现了 Node.js 环境下数据的强类型定义、构建与序列化。</strong> 这份 <code>.proto</code> 文件为你节省了大量手动定义数据结构的时间，并且保证了与后端（或其他服务）数据格式的绝对一致性。接下来，让我们看看在 Go 语言中，这份统一的契约如何发挥更大的作用。</p><h2 id="💻-go-版代码一键出炉" tabindex="-1">💻 Go 版代码一键出炉 <a class="header-anchor" href="#💻-go-版代码一键出炉" aria-label="Permalink to &quot;💻 Go 版代码一键出炉&quot;">​</a></h2><p>对于 Go 语言的开发者来说，生成和使用 Protocol Buffers 代码同样非常顺滑。</p><p>首先，安装 Go 语言的 Protocol Buffers 和 gRPC 插件：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> google.golang.org/protobuf/cmd/protoc-gen-go@latest</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，运行 <code>protoc</code> 命令生成 Go 代码：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">protoc</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --go_out=.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --go-grpc_out=.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --proto_path=.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  user.proto</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这会生成两个核心文件：</p><ul><li><code>user.pb.go</code>：包含 <code>User</code> 结构体的定义，以及它对应的序列化和反序列化方法。</li><li><code>user_grpc.pb.go</code>：如果你的 <code>.proto</code> 文件中定义了 gRPC 服务，这个文件会生成 <code>UserServiceServer</code> 接口（供你实现服务逻辑）和 <code>UserServiceClient</code> 接口（供客户端调用服务）。</li></ul><p>这里是一个简单的 Go gRPC 服务器示例，展示了如何使用生成的 <code>user.pb.go</code> 和 <code>user_grpc.pb.go</code>：</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// server.go</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">context</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	pb </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">your/module/user</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 替换为你的模块路径，例如 &quot;github.com/yourusername/yourproject/user&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">google.golang.org/grpc</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// userServer 实现了生成代码中的 UserServiceServer 接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> userServer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	pb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UnimplementedUserServiceServer</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 嵌入这个是为了向前兼容性，当 .proto 文件增加新方法时不会编译报错</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// GetUser 是一个 gRPC 方法的示例实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Received: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, req.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 这里可以添加业务逻辑，比如从数据库查询用户</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 为了演示，我们直接回显请求中的 User 对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 监听 TCP 端口 50051</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	lis, err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> net.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;tcp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:50051&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fatalf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;failed to listen: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 创建一个新的 gRPC 服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> grpc.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">NewServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 注册你的 UserService 到 gRPC 服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	pb.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RegisterUserServiceServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;server listening at </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Addr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 启动 gRPC 服务器，开始处理请求</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Serve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lis); err </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fatalf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;failed to serve: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, err)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>通过这个 Go 语言的例子，我们不仅看到了如何使用 <code>.proto</code> 定义数据结构，更重要的是，它为构建<strong>高性能、跨语言的 RPC 服务</strong>提供了坚实的基础。</p><hr><p>从最初的痛点——格式混乱、性能低下、多语言协作困难——到引入 <code>.proto</code> 文件，我们看到了一个优雅而强大的解决方案。Protocol Buffers 不仅仅是一种数据序列化格式，更是一种<strong>服务间通信的契约</strong>，确保了在复杂的分布式系统中，数据能被高效、准确地理解和处理。</p><p><strong>强烈建议你亲自跟着这些步骤敲几遍代码，从定义 <code>.proto</code> 文件到生成代码，再到成功运行一个简单的示例。</strong> 只有亲手实践，你才能真正理解并掌握 Protocol Buffers 的好用之处。</p><h1 id="链接" tabindex="-1">链接 <a class="header-anchor" href="#链接" aria-label="Permalink to &quot;链接&quot;">​</a></h1><ul><li><a href="https://www.topgoer.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Protobuf%E8%AF%AD%E6%B3%95.html" target="_blank" rel="noreferrer">Protobuf 语法</a></li><li><a href="https://cloud.tencent.com/developer/article/2342109" target="_blank" rel="noreferrer">探秘 Proto 文件：解析定义与参数揭秘</a></li><li><a href="https://go-kratos.dev/docs/guide/api-protobuf/" target="_blank" rel="noreferrer">Protobuf 规范</a></li></ul>`,45)]))}const c=i(l,[["render",p]]);export{g as __pageData,c as default};
