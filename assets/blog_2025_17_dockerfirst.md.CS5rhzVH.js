import{_ as i,C as n,c as l,o as e,G as p,a6 as t}from"./chunks/framework.CBA1pFat.js";const u=JSON.parse('{"title":"Docker 入门教程","description":"全面的 Docker 入门指南，通过实战案例学会容器化部署。涵盖 Docker 核心概念、Dockerfile 编写、静态网站部署、Go 服务器容器化等内容，帮助前端和后端工程师快速掌握容器技术。","frontmatter":{"title":"Docker 入门教程","description":"全面的 Docker 入门指南，通过实战案例学会容器化部署。涵盖 Docker 核心概念、Dockerfile 编写、静态网站部署、Go 服务器容器化等内容，帮助前端和后端工程师快速掌握容器技术。","tags":["Docker","容器化","Dockerfile","前端部署","Go","Nginx","微服务","DevOps","容器技术","部署优化"],"author":"mCell","head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/17_dockerfirst"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/17_dockerfirst"}]]},"headers":[],"relativePath":"blog/2025/17_dockerfirst.md","filePath":"blog/2025/17_dockerfirst.md","lastUpdated":1756399682000}'),r={name:"blog/2025/17_dockerfirst.md"};function h(k,s,o,d,c,g){const a=n("VideoEmbed");return e(),l("div",null,[p(a,{url:"https://www.bilibili.com/video/BV1VTruYsEYg",title:"原子能 - 为什么程序员都应该学用容器技术【让编程再次伟大#26】"}),s[0]||(s[0]=t(`<h1 id="docker-入门教程" tabindex="-1"><strong>Docker 入门教程</strong> <a class="header-anchor" href="#docker-入门教程" aria-label="Permalink to &quot;**Docker 入门教程**&quot;">​</a></h1><h2 id="为什么我们需要-docker" tabindex="-1"><strong>为什么我们需要 Docker？</strong> <a class="header-anchor" href="#为什么我们需要-docker" aria-label="Permalink to &quot;**为什么我们需要 Docker？**&quot;">​</a></h2><p>在开发中，你是否遇到过这些问题？</p><ul><li>&quot;我的电脑上明明是好的，怎么到服务器上就出错了？&quot;</li><li>新同事入职，花了一整天时间配置开发环境，安装各种依赖。</li><li>项目依赖 Node.js v14，而另一个项目需要 v18，版本切换很麻烦。</li><li>部署应用时，需要在服务器上手动执行一长串命令，容易出错。</li></ul><p>这些问题的本质是 <strong>环境不一致</strong>。Docker 就是为了解决这个问题而生的。</p><p>你可以把 Docker 想象成一个标准化的“集装箱”。我们把应用程序以及它运行所需的一切（代码、运行时、库、环境变量）都打包到这个集装箱里。然后，这个集装箱可以在任何安装了 Docker 的机器上运行，无论是你的笔记本、同事的电脑，还是云服务器，表现都完全一样。</p><p>对我们工程师来说，Docker 的好处是：</p><ul><li><strong>环境一致性</strong>：彻底告别“在我电脑上是好的”。</li><li><strong>快速部署</strong>：应用的启动和部署变得极其简单和迅速。</li><li><strong>轻松迁移</strong>：应用可以轻松地从一个环境迁移到另一个环境。</li><li><strong>隔离性</strong>：不同项目的环境互不干扰。</li></ul><h2 id="docker-的核心概念" tabindex="-1"><strong>Docker 的核心概念</strong> <a class="header-anchor" href="#docker-的核心概念" aria-label="Permalink to &quot;**Docker 的核心概念**&quot;">​</a></h2><p>Docker 有三个核心概念，理解了它们，你就理解了 Docker 的一半。</p><ol><li><p><strong>镜像 (Image)</strong></p><ul><li><strong>是什么</strong>：一个只读的模板，包含了运行应用程序所需的一切。比如，一个 Ubuntu 操作系统、一个 Node.js 运行时、你的应用代码等。</li><li><strong>好比是</strong>：一张系统安装光盘，或者一个类的定义。</li></ul></li><li><p><strong>容器 (Container)</strong></p><ul><li><strong>是什么</strong>：镜像的运行实例。一个镜像可以创建出很多个容器。</li><li><strong>好比是</strong>：用光盘安装好的系统，或者通过类 <code>new</code> 出来的对象实例。容器是独立、可运行的。</li></ul></li><li><p><strong>Dockerfile</strong></p><ul><li><strong>是什么</strong>：一个文本文件，用来定义如何构建一个镜像。里面包含了一系列指令，比如“基于哪个基础镜像”、“拷贝哪些文件进去”、“执行什么命令”等。</li><li><strong>好比是</strong>：一张“菜谱”，Docker 根据这张菜谱就能做出“镜像”这道菜。</li></ul></li></ol><p>它们的关系是：我们通过 <code>Dockerfile</code> 来创建 <code>镜像</code>，然后通过 <code>镜像</code> 来运行 <code>容器</code>。</p><h2 id="动手实践-第一个-docker-容器" tabindex="-1"><strong>动手实践：第一个 Docker 容器</strong> <a class="header-anchor" href="#动手实践-第一个-docker-容器" aria-label="Permalink to &quot;**动手实践：第一个 Docker 容器**&quot;">​</a></h2><p>首先，请确保你已经安装了 Docker。可以从 <a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noreferrer">Docker 官网</a> 下载。</p><p>安装完成后，打开命令行工具，运行你的第一个容器：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello-world</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果一切顺利，你会看到 Docker 下载 <code>hello-world</code> 镜像，并运行它，然后输出一段欢迎信息。这证明你的 Docker 环境已经就绪。</p><h2 id="前端工程师实战-打包一个静态网站" tabindex="-1"><strong>前端工程师实战：打包一个静态网站</strong> <a class="header-anchor" href="#前端工程师实战-打包一个静态网站" aria-label="Permalink to &quot;**前端工程师实战：打包一个静态网站**&quot;">​</a></h2><p>假设你有一个简单的静态网站项目，目录结构如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/my-static-site</span></span>
<span class="line"><span>  |-- index.html</span></span>
<span class="line"><span>  |-- style.css</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们希望用 Nginx 服务器来运行它。</p><p><strong>第一步：编写 Dockerfile</strong></p><p>在项目根目录下，创建一个名为 <code>Dockerfile</code> 的文件（没有扩展名），内容如下：</p><div class="language-dockerfile vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 步骤1：选择一个基础镜像，这里我们选择官方的 Nginx 镜像</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nginx:alpine</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 步骤2：将我们项目中的文件，拷贝到镜像里 Nginx 的默认网站根目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . /usr/share/nginx/html</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Nginx 镜像默认会启动 Nginx 服务，并监听 80 端口，所以这里不需要额外指令</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这个 Dockerfile 非常简单，只有两行：</p><ul><li><code>FROM</code>：指定基础镜像。我们不需要从零开始，直接站在 Nginx 的肩膀上。<code>alpine</code> 是一个极简的 Linux 发行版，让我们的镜像体积更小。</li><li><code>COPY</code>：将当前目录（<code>.</code>）下的所有文件，复制到镜像的 <code>/usr/share/nginx/html</code> 目录下。</li></ul><p><strong>第二步：构建镜像</strong></p><p>在项目根目录下，执行以下命令：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -t 参数给镜像取一个名字，格式是 repository:tag</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># . 表示 Dockerfile 在当前目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-static-site:1.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>构建完成后，你可以用 <code>docker images</code> 命令查看本地已有的镜像。</p><p><strong>第三步：运行容器</strong></p><p>现在，用我们刚创建的镜像来启动一个容器：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -d 参数表示在后台运行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -p 8080:80 将主机的 8080 端口映射到容器的 80 端口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># --name 给容器取一个名字</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 8080:80</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-site</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-static-site:1.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在，打开浏览器访问 <code>http://localhost:8080</code>，你应该能看到你的网站了！</p><p>你可以用 <code>docker ps</code> 查看正在运行的容器，用 <code>docker stop my-site</code> 停止它。</p><h2 id="golang-工程师实战-打包一个-web-服务器" tabindex="-1"><strong>Golang 工程师实战：打包一个 Web 服务器</strong> <a class="header-anchor" href="#golang-工程师实战-打包一个-web-服务器" aria-label="Permalink to &quot;**Golang 工程师实战：打包一个 Web 服务器**&quot;">​</a></h2><p>现在我们来看一个 Golang 的例子。假设你有一个简单的 <code>main.go</code> 文件：</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.go</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">net/http</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	http.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HandleFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">w</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResponseWriter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fprintf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello from Golang Docker!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	fmt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Server starting on port 8080...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	http.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListenAndServe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:8080&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>第一步：编写 Dockerfile</strong></p><p>这次我们使用“多阶段构建”（multi-stage build），这是一个非常实用的技巧，可以让最终的镜像体积变得极小。</p><div class="language-dockerfile vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># --- 第一阶段：构建阶段 ---</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用官方的 Golang 镜像作为构建环境</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> golang:1.22-alpine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> builder</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置工作目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 复制 Go 模块文件并下载依赖</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> go.mod ./</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> go.sum ./</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> go mod download</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 复制源代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 构建 Go 应用，CGO_ENABLED=0 是为了静态编译，不依赖 C 库</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -o /app/main 表示将编译产物输出到 /app/main</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RUN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CGO_ENABLED=0 GOOS=linux go build -o /app/main .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># --- 第二阶段：运行阶段 ---</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用一个极简的空白镜像 scratch，或者 alpine</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> alpine:latest</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置工作目录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WORKDIR</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /app</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 从构建阶段（builder）复制编译好的二进制文件到当前阶段</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COPY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> --from=builder /app/main .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 暴露 8080 端口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">EXPOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 8080</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 容器启动时执行的命令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/app/main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>这个 Dockerfile 分为两个阶段：</p><ol><li><strong><code>builder</code> 阶段</strong>：使用完整的 Go 环境编译代码，生成一个二进制文件 <code>/app/main</code>。</li><li><strong>运行阶段</strong>：使用一个非常干净、轻量的 <code>alpine</code> 镜像，只把上个阶段编译好的二进制文件复制进来。最终我们得到的镜像不包含任何 Go 编译工具和源代码，只有那个可执行文件，非常小。</li></ol><p><strong>第二步：构建和运行</strong></p><p>构建和运行的命令与前端例子类似：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 构建镜像</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-hello-server:1.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 运行容器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 8080:8080</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-hello-server:1.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>现在访问 <code>http://localhost:8080</code>，你将看到来自 Go 服务器的问候。</p><h2 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h2><p>这只是一个开始，Docker 的世界还有很多值得探索的功能，比如 <code>Docker Compose</code> 用于编排多个容器，<code>Docker Hub</code> 用于分享镜像等。</p>`,49))])}const E=i(r,[["render",h]]);export{u as __pageData,E as default};
