import{_ as t,c as s,o as e,a2 as r}from"./chunks/framework.D36_hvi3.js";const k=JSON.parse('{"title":"你可能在用错密码：服务端密码安全的真相与陷阱","description":"探讨服务端密码安全的重要性和常见误区，为密码安全体系专栏开篇","frontmatter":{"title":"你可能在用错密码：服务端密码安全的真相与陷阱","description":"探讨服务端密码安全的重要性和常见误区，为密码安全体系专栏开篇","date":"2025-01-24T00:00:00.000Z","tags":["密码安全","服务端安全","数据泄露","安全开发"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/10_serverpwd"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/10_serverpwd"}]]},"headers":[],"relativePath":"blog/2025/10_serverpwd.md","filePath":"blog/2025/10_serverpwd.md","lastUpdated":1755168132000}'),i={name:"blog/2025/10_serverpwd.md"};function o(l,a,n,p,h,d){return e(),s("div",null,a[0]||(a[0]=[r(`<h1 id="你可能在用错密码-服务端密码安全的真相与陷阱" tabindex="-1">你可能在用错密码：服务端密码安全的真相与陷阱 <a class="header-anchor" href="#你可能在用错密码-服务端密码安全的真相与陷阱" aria-label="Permalink to &quot;你可能在用错密码：服务端密码安全的真相与陷阱&quot;">​</a></h1><p>这是我写下服务端密码安全专栏的第一篇，也是想敲响的一个警钟：密码，不只是登录的钥匙，更可能是一次数据泄露的开关。</p><p>不夸张地说，每一个不安全的密码实现，都是一次&quot;待触发的事故现场&quot;。而这些事故，从未停过。</p><hr><h2 id="密码泄露-从未遥远" tabindex="-1">密码泄露，从未遥远 <a class="header-anchor" href="#密码泄露-从未遥远" aria-label="Permalink to &quot;密码泄露，从未遥远&quot;">​</a></h2><p>或许还记得，LinkedIn 曾因密码存储未加盐而导致 <a href="https://en.wikipedia.org/wiki/2012_LinkedIn_hack" target="_blank" rel="noreferrer">1.1 亿用户密码泄露</a>。攻击者轻松利用&quot;彩虹表&quot;反查出明文。</p><p>当然，如果觉得上面的例子比较老旧，没有很强的说服力，你也可以在这里看到今年更多的密码泄露的新闻<a href="https://www.anyong.net/2025shijian" target="_blank" rel="noreferrer">2025 年重大数据泄露事件汇总</a>。</p><p>问题不是&quot;密码被破解&quot;，而是&quot;密码根本没被好好保护&quot;。</p><hr><h2 id="开发者最常犯的几个错" tabindex="-1">开发者最常犯的几个错 <a class="header-anchor" href="#开发者最常犯的几个错" aria-label="Permalink to &quot;开发者最常犯的几个错&quot;">​</a></h2><p>下面这些&quot;经典错误&quot;，可能你也见过、甚至写过：</p><h3 id="明文存储" tabindex="-1">明文存储 <a class="header-anchor" href="#明文存储" aria-label="Permalink to &quot;明文存储&quot;">​</a></h3><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">password </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FormValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;password&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">db.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;INSERT INTO users (password) VALUES (?)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, password) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 最初接触后端开发的我是这样的（</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这在数据库层面相当于裸奔——只要有人能查库，就能看到全部用户密码。</p><h3 id="弱哈希算法" tabindex="-1">弱哈希算法 <a class="header-anchor" href="#弱哈希算法" aria-label="Permalink to &quot;弱哈希算法&quot;">​</a></h3><p>用 <a href="https://md5.cc/news1.aspx" target="_blank" rel="noreferrer">MD5(password)</a> 存密码，看似加密，实际上在攻击者眼里只是&quot;熟练操作&quot;：</p><ul><li>入门开发者通常不设置盐(虽然 MD5 也可以使用盐)，容易被彩虹表秒破</li><li>算法快，暴力破解成本低</li></ul><h3 id="加错了盐-salt" tabindex="-1">加错了盐（Salt） <a class="header-anchor" href="#加错了盐-salt" aria-label="Permalink to &quot;加错了盐（Salt）&quot;">​</a></h3><p>即使用了 <code>bcrypt</code>，但若所有密码都用同一个盐，那就是&quot;安全的幻觉&quot;。正确做法是：<strong>为每个密码生成独立的随机盐</strong>。</p><hr><h2 id="前端加密-安全" tabindex="-1">前端加密 ≠ 安全 <a class="header-anchor" href="#前端加密-安全" aria-label="Permalink to &quot;前端加密 ≠ 安全&quot;">​</a></h2><p>很多初学者会问：</p><blockquote><p>我前端加密过了呀，AES、Base64 都用了，还不安全吗？</p></blockquote><p>答案是：<strong>加密 ≠ 安全，安全是系统性防御。</strong></p><p>前端加密只是让数据在传输时&quot;看起来安全&quot;，但如果服务端仍然存明文，那加密只是个花瓶：</p><ul><li>前端加密密钥（常有的事情，毕竟 F12 就看到了）一旦泄露，所有密码裸奔</li><li>加密内容如果直接存，攻击者照样可以离线解密</li></ul><p>服务端需要<strong>独立负责</strong>对密码的安全存储：合理的哈希算法、动态盐值、强策略校验、重置机制、审计与防爆破。</p><hr><h2 id="这个专栏要解决什么" tabindex="-1">这个专栏要解决什么？ <a class="header-anchor" href="#这个专栏要解决什么" aria-label="Permalink to &quot;这个专栏要解决什么？&quot;">​</a></h2><p>我希望通过这个专栏，和你一起系统梳理服务端密码管理的各个方面：</p><ul><li><p><strong>密码的本质与误解</strong>，先打好基础，扫除认知盲区。</p></li><li><p><strong>哈希算法选择和盐的使用</strong>，深入技术细节，解决&quot;核心痛点&quot;。</p></li><li><p><strong>密码校验与攻击面</strong>，从安全攻防角度提升认知，避免漏洞。</p></li><li><p><strong>密码重置机制</strong>，处理实战中常被忽视的安全环节。</p></li><li><p><strong>密码强度策略</strong>，兼顾安全与用户体验，落地应用。</p></li></ul><p>你将看到的不只是代码，而是背后的<strong>安全理念</strong>与<strong>工程权衡</strong>。</p><hr><h2 id="安全-是系统性的工程-不是-那一行代码" tabindex="-1">安全，是系统性的工程，不是&quot;那一行代码&quot; <a class="header-anchor" href="#安全-是系统性的工程-不是-那一行代码" aria-label="Permalink to &quot;安全，是系统性的工程，不是&quot;那一行代码&quot;&quot;">​</a></h2><p>密码管理不是一个函数的问题，而是一整套机制的设计。</p><p>你写的服务，承载的不只是技术逻辑，还有用户的信任与隐私。如果一行 <code>md5(password)</code> 就能让系统崩塌，那么修补的就不是代码，而是你的信誉。</p><p>所以，不要&quot;写一个登录接口&quot;这么简单地想问题。请你带着<strong>对风险的敬畏</strong>，一起来构建属于现代服务端的密码安全体系。</p><hr><p>下一篇，我们将从最基本也最被误解的一个概念讲起：<strong>密码的本质与误解？</strong></p>`,39)]))}const c=t(i,[["render",o]]);export{k as __pageData,c as default};
