import{_ as i,c as a,o as n,ah as e}from"./chunks/framework.Dmpd2wBz.js";const o=JSON.parse('{"title":"探索 JS 异步编程：从 setTimeout 到生成器的六种定时实现","description":"以“每秒打印一个数字”为引，本文深入剖析了 JavaScript 中实现定时任务的六种核心方法。从经典的闭包问题到现代的 async/await，再到生成器与函数式编程，带你领略 JS 异步编程的演进与魅力。","frontmatter":{"title":"探索 JS 异步编程：从 setTimeout 到生成器的六种定时实现","description":"以“每秒打印一个数字”为引，本文深入剖析了 JavaScript 中实现定时任务的六种核心方法。从经典的闭包问题到现代的 async/await，再到生成器与函数式编程，带你领略 JS 异步编程的演进与魅力。","date":"2025-01-21T00:00:00.000Z","tags":["JavaScript","异步编程","Promise","生成器函数","定时器"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/03_jsprintnum"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/03_jsprintnum"}]]},"headers":[],"relativePath":"blog/2025/03_jsprintnum.md","filePath":"blog/2025/03_jsprintnum.md","lastUpdated":1755345784000}'),t={name:"blog/2025/03_jsprintnum.md"};function l(p,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="探索-js-异步编程-从-settimeout-到生成器的六种定时实现" tabindex="-1">探索 JS 异步编程：从 setTimeout 到生成器的六种定时实现 <a class="header-anchor" href="#探索-js-异步编程-从-settimeout-到生成器的六种定时实现" aria-label="Permalink to &quot;探索 JS 异步编程：从 setTimeout 到生成器的六种定时实现&quot;">​</a></h1><blockquote><p>本文将摒弃 Web API (<code>requestAnimationFrame</code>)，纯粹在 Node 运行环境中，由浅入深地探讨六种实现方案，展示不同编程范式下的巧思。</p></blockquote><p>“每秒打印一个数字”——这个看似简单的编程任务，是衡量 JavaScript 开发者对异步编程理解程度的一块绝佳试金石。不仅考察了对定时器的掌握，更能引出闭包、Promise、async/await、生成器乃至函数式编程等核心概念。</p><h3 id="方案一-经典的-settimeout-与闭包" tabindex="-1">方案一：经典的 <code>setTimeout</code> 与闭包 <a class="header-anchor" href="#方案一-经典的-settimeout-与闭包" aria-label="Permalink to &quot;方案一：经典的 \`setTimeout\` 与闭包&quot;">​</a></h3><p>这是最容易想到的方案，但也暗藏着最容易遇到的“闭包陷阱”。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>核心思路：</strong> 通过一次循环，同时启动 10 个定时器。通过将延迟时间设置为 <code>i * 1000</code>，巧妙地让它们在不同的时间点（第 1 秒、第 2 秒……）触发，从而实现顺序打印。</p><p><strong>关键点解析：</strong></p><ul><li><strong><code>let</code> 的作用</strong>：在这里，使用 <code>let</code> 声明 <code>i</code> 至关重要。在每次循环中，<code>let</code> 都会创建一个新的块级作用域，因此每个 <code>setTimeout</code> 的回调函数都“捕获”了一个独立的 <code>i</code> 变量。</li><li><strong>如果使用 <code>var</code> 会怎样？</strong> 若将 <code>let</code> 换成 <code>var</code>，由于 <code>var</code> 是函数作用域且存在变量提升，所有回调函数将共享同一个 <code>i</code>。当定时器触发时，循环早已结束，此时 <code>i</code> 的值已变为 <code>11</code>，导致最终会连续打印十个 <code>11</code>。这是经典的“循环中闭包”问题。</li></ul><h3 id="方案二-setinterval-状态管理" tabindex="-1">方案二：<code>setInterval</code> 状态管理 <a class="header-anchor" href="#方案二-setinterval-状态管理" aria-label="Permalink to &quot;方案二：\`setInterval\` 状态管理&quot;">​</a></h3><p><code>setInterval</code> 提供了一种更“状态化”的实现方式，它创建一个唯一的、重复执行的定时任务。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> intervalId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(intervalId); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 必须清除定时器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>核心思路：</strong> 启动一个每秒执行一次的“节拍器”。在每次节拍触发时，打印当前计数器的值，然后递增计数器。当计数器达到目标后，销毁这个节拍器。</p><p><strong>关键点解析：</strong></p><ul><li><strong>状态维护</strong>：此方法需要一个外部变量 <code>i</code> 来追踪当前的状态（打印到第几个数）。</li><li><strong>及时清理</strong>：<code>clearInterval(intervalId)</code> 是不可或缺的一步。忘记清理会导致定时器在后台永久运行，造成内存泄漏和不必要的计算资源浪费。在组件化开发（如 React, Vue）中，这尤其重要，通常需要在组件卸载时执行清理。</li></ul><h3 id="方案三-递归-settimeout-的精准控制" tabindex="-1">方案三：递归 <code>setTimeout</code> 的精准控制 <a class="header-anchor" href="#方案三-递归-settimeout-的精准控制" aria-label="Permalink to &quot;方案三：递归 \`setTimeout\` 的精准控制&quot;">​</a></h3><p>使用递归的方式来链接每一次的 <code>setTimeout</code>，这是一种比 <code>setInterval</code> 更健壮的模式。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithRecursion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 递归的终止条件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printNumbersWithRecursion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>核心思路：</strong> 执行当前任务（打印数字），然后设置一个定时器，在 1 秒后调用自身并传入下一个数字。这个过程形成了一条“执行-&gt;等待-&gt;执行”的递归链。</p><p><strong>关键点解析：</strong></p><ul><li><strong>执行间隔更精确</strong>：<code>setInterval</code> 的问题在于，它会严格按照设定的间隔时间将回调函数推入事件队列，而不关心上一个任务是否执行完毕。如果任务执行时间超过间隔时间，可能导致任务堆积。而递归 <code>setTimeout</code> 确保了只有在当前任务完成后，才会规划下一次任务，两次任务的<strong>间隔</strong>至少为 1 秒，避免了任务重叠。</li><li><strong>终止条件</strong>：递归必须有明确的终止条件 (<code>if (i &gt; 10) return;</code>)，否则将导致无限递归，最终可能耗尽调用栈（尽管此处因为异步不会直接栈溢出）。</li></ul><h3 id="方案四-promise-与-async-await-的同步化表达" tabindex="-1">方案四：<code>Promise</code> 与 <code>async/await</code> 的同步化表达 <a class="header-anchor" href="#方案四-promise-与-async-await-的同步化表达" aria-label="Permalink to &quot;方案四：\`Promise\` 与 \`async/await\` 的同步化表达&quot;">​</a></h3><p><code>async/await</code> 是 ES7 引入的语法糖，用它可以让异步代码的编写方式无限接近于同步代码，极大地提升了可读性。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 首先，封装一个可暂停执行的 sleep 函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, ms));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithAsyncAwait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等待1秒</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>核心思路：</strong> 将延时操作封装成一个返回 <code>Promise</code> 的 <code>sleep</code> 函数。在 <code>async</code> 函数内部，通过 <code>await</code> 关键字暂停 <code>for</code> 循环的执行，直到 <code>sleep</code> 函数的 <code>Promise</code> 状态变为 <code>resolved</code> 后再继续下一次循环。</p><p><strong>关键点解析：</strong></p><ul><li><strong>异步代码同步化</strong>：这是 <code>async/await</code> 最大的优势。代码从上到下执行，逻辑清晰，没有回调地狱。</li><li><strong><code>await</code> 的本质</strong>：<code>await</code> 实际上是暂停了 <code>async</code> 函数的执行，并交出了执行权。它并不会阻塞整个 JavaScript 线程。</li></ul><h3 id="方案五-生成器函数-generator-的迭代控制" tabindex="-1">方案五：生成器函数（Generator）的迭代控制 <a class="header-anchor" href="#方案五-生成器函数-generator-的迭代控制" aria-label="Permalink to &quot;方案五：生成器函数（Generator）的迭代控制&quot;">​</a></h3><p>生成器函数提供了一种更精细的控制函数执行流程的方式，它可以被看作是状态机或可暂停的函数。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> numberGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 暂停并产出一个 Promise</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    yield</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 遍历生成器产出的每一个 Promise</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> numberGenerator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promise; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等待当前 Promise 完成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><strong>核心思路：</strong> 生成器函数 <code>numberGenerator</code> 并不直接执行打印，而是在每次循环时 <code>yield</code>（产出）一个包含了定时打印逻辑的 <code>Promise</code>。外部的 <code>async</code> 函数通过 <code>for...of</code> 循环来消费这些 <code>Promise</code>，每次 <code>await</code> 一个，从而驱动生成器一步步执行。</p><p><strong>关键点解析：</strong></p><ul><li><strong>执行控制权的反转</strong>：生成器将执行的控制权交给了调用方。调用方决定何时通过 <code>next()</code>（或在 <code>for...of</code> 中隐式调用）来继续执行。</li><li><strong>异步迭代</strong>：这个模式完美地展示了如何将一个迭代器与异步操作结合。它也是 ES2018 中引入的“异步迭代器”（<code>for await...of</code>）的前身和思想基础。</li></ul><h3 id="方案六-array-reduce-的函数式编程风格" tabindex="-1">方案六：<code>Array.reduce</code> 的函数式编程风格 <a class="header-anchor" href="#方案六-array-reduce-的函数式编程风格" aria-label="Permalink to &quot;方案六：\`Array.reduce\` 的函数式编程风格&quot;">​</a></h3><p>最后，我们来看一种利用函数式编程思想，通过 <code>reduce</code> 方法动态构建 Promise 链的精妙实现。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> printNumbersWithReduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ length: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">promiseChain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">currentNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promiseChain.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNumber);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>核心思路：</strong> 将一个数字数组 <code>[1, 2, ..., 10]</code> 通过 <code>reduce</code> 方法，“折叠”成一个顺序执行的 Promise 链。<code>reduce</code> 的初始值是一个立即 resolved 的 <code>Promise</code>。在每次迭代中，我们通过 <code>.then()</code> 在上一个 <code>Promise</code> 完成后，追加一个新的、包含延时打印逻辑的 <code>Promise</code>。</p><p><strong>关键点解析：</strong></p><ul><li><strong>动态 Promise 链</strong>：这种写法的核心是动态构建一个 <code>p.then(() =&gt; p1).then(() =&gt; p2)...</code> 的链条，确保了任务的严格串行化。</li><li><strong>函数式思维</strong>：它体现了函数式编程中数据转换和组合的思想，代码高度声明式，虽然初看可能较为费解，但逻辑严谨且内聚。</li></ul><h3 id="总结与对比" tabindex="-1">总结与对比 <a class="header-anchor" href="#总结与对比" aria-label="Permalink to &quot;总结与对比&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">方案</th><th style="text-align:left;">实现方式</th><th style="text-align:left;">优点</th><th style="text-align:left;">缺点 / 注意事项</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>setTimeout</code> 循环</strong></td><td style="text-align:left;">一次性启动多个延时任务</td><td style="text-align:left;">简单直观，代码量少</td><td style="text-align:left;">需注意 <code>let</code> 和 <code>var</code> 作用域差异，避免闭包陷阱</td></tr><tr><td style="text-align:left;"><strong><code>setInterval</code></strong></td><td style="text-align:left;">单个重复任务，状态管理</td><td style="text-align:left;">内存占用稳定，逻辑集中</td><td style="text-align:left;">任务可能堆积，必须手动清理以防内存泄漏</td></tr><tr><td style="text-align:left;"><strong>递归 <code>setTimeout</code></strong></td><td style="text-align:left;">链式调用，任务自我延续</td><td style="text-align:left;">间隔精确，避免任务堆积，比 <code>setInterval</code> 更健壮</td><td style="text-align:left;">需要设计好递归终止条件</td></tr><tr><td style="text-align:left;"><strong><code>async/await</code></strong></td><td style="text-align:left;">同步化书写异步代码</td><td style="text-align:left;"><strong>可读性极高</strong>，符合直觉，是现代 JS 异步首选</td><td style="text-align:left;">需要额外封装 <code>sleep</code> 函数，依赖 <code>Promise</code></td></tr><tr><td style="text-align:left;"><strong>生成器函数</strong></td><td style="text-align:left;">迭代器模式，手动控制流程</td><td style="text-align:left;">控制粒度精细，是理解异步迭代器的基础</td><td style="text-align:left;">概念相对复杂，代码冗余度稍高</td></tr><tr><td style="text-align:left;"><strong><code>Array.reduce</code></strong></td><td style="text-align:left;">函数式编程，构建 Promise 链</td><td style="text-align:left;">代码精炼，声明式，展示了函数式组合能力</td><td style="text-align:left;"><strong>可读性较差</strong>，对新手不友好，不建议在业务中滥用</td></tr></tbody></table><h3 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="noreferrer">MDN: 数组的 reduce 方法</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer">MDN: Promise 异步编程</a></li><li><a href="https://juejin.cn/post/7380942251411226659?searchId=202503302032262C8FF11FB96465422772" target="_blank" rel="noreferrer">面试官：你可以终止 forEach 吗？</a></li></ul>`,43)]))}const c=i(t,[["render",l]]);export{o as __pageData,c as default};
