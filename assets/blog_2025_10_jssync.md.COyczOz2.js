import{_ as a,C as t,c as n,o as l,G as e,a9 as p}from"./chunks/framework.DsVI9alt.js";const y=JSON.parse('{"title":"JavaScript 运行机制详解：再谈 Event Loop","description":"本文从经典的 Promise 与 setTimeout 执行顺序问题入手，深入浅出地剖析了 JavaScript 的单线程模型、事件循环（Event Loop）机制。通过辨析宏任务与微任务的区别与优先级，帮助你彻底理解 JS 异步执行的底层原理，看懂页面卡顿的真相。","frontmatter":{"title":"JavaScript 运行机制详解：再谈 Event Loop","description":"本文从经典的 Promise 与 setTimeout 执行顺序问题入手，深入浅出地剖析了 JavaScript 的单线程模型、事件循环（Event Loop）机制。通过辨析宏任务与微任务的区别与优先级，帮助你彻底理解 JS 异步执行的底层原理，看懂页面卡顿的真相。","tags":["JavaScript","浏览器","事件循环","Promise","异步机制"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/10_jssync"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/10_jssync"}]]},"headers":[],"relativePath":"blog/2025/10_jssync.md","filePath":"blog/2025/10_jssync.md","lastUpdated":1758819637000}'),h={name:"blog/2025/10_jssync.md"};function o(k,s,r,E,c,d){const i=t("VideoEmbed");return l(),n("div",null,[e(i,{url:"https://youtu.be/cCOL7MC4Pl0?si=fwgtpeQNmohgyjEZ",title:"Jake Archibald: 在循环 - JSConf.Asia"}),s[0]||(s[0]=p(`<h1 id="javascript-运行机制详解-再谈-event-loop" tabindex="-1">JavaScript 运行机制详解：再谈 Event Loop <a class="header-anchor" href="#javascript-运行机制详解-再谈-event-loop" aria-label="Permalink to &quot;JavaScript 运行机制详解：再谈 Event Loop&quot;">​</a></h1><blockquote><p>本文从经典的 Promise 与 setTimeout 执行顺序问题入手，深入浅出地剖析了 JavaScript 的单线程模型、事件循环（Event Loop）机制。通过辨析宏任务与微任务的区别与优先级，帮助你彻底理解 JS 异步执行的底层原理，看懂页面卡顿的真相。</p></blockquote><p>我常常在各种场合被问到类似下面代码的输出顺序。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;promise&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>如果你能毫不犹豫地答出 <code>start, end, promise, setTimeout</code>，并解释其原因，那么你对 JS 的异步机制已经有了不错的理解。如果你还有一丝困惑，希望本文能帮助你彻底梳理清楚。</p><p>这个问题的背后，是整个 JavaScript 的运行模型（runtime model），也就是我们常说的“事件循环”（Event Loop）。理解它，是前端工程师进阶的必经之路。</p><h2 id="为什么-javascript-是单线程" tabindex="-1"><strong>为什么 JavaScript 是单线程？</strong> <a class="header-anchor" href="#为什么-javascript-是单线程" aria-label="Permalink to &quot;**为什么 JavaScript 是单线程？**&quot;">​</a></h2><p>首先，我们必须记住一个基本事实：<strong>JavaScript 语言是一门单线程语言。</strong></p><p>这意味着，在任何一个时刻，JS 引擎只能执行一段代码。为什么这么设计？这与它的初衷有关。JavaScript 最初是为浏览器设计的，用于处理用户的交互，比如鼠标点击、键盘输入，以及操作 DOM。</p><p>试想一下，如果 JavaScript 是多线程的，会发生什么？一个线程要在一个 DOM 节点上增加内容，另一个线程要删除这个节点。那么浏览器应该听谁的？这会带来极其复杂的同步问题。为了避免这种复杂性，JavaScript 从诞生起就选择了单线程。</p><p>这既是它的优点，也是它的缺点。优点是简单，没有多线程的竞态、死锁等问题。缺点是，如果一个任务耗时很长，整个程序就会被“卡住”，无法响应其他操作。</p><h2 id="浏览器-一个多进程的-操作系统" tabindex="-1"><strong>浏览器：一个多进程的“操作系统”</strong> <a class="header-anchor" href="#浏览器-一个多进程的-操作系统" aria-label="Permalink to &quot;**浏览器：一个多进程的“操作系统”**&quot;">​</a></h2><p>“JS 是单线程的”这个说法其实不完全准确。准确来说，<strong>执行 JavaScript 代码的那个主线程是单线程的</strong>。</p><p>现代浏览器（以 Chrome 为例）本身是一个非常复杂的程序，它采用了多进程架构来保证稳定性和安全性。你可以打开 Chrome 的任务管理器（“更多工具” &gt; “任务管理器”）看看，通常会看到好几个进程：</p><blockquote><ul><li><strong>浏览器进程（Browser Process）</strong>：负责浏览器界面的“外壳”，比如地址栏、书签、前进后退按钮，以及协调其他进程。</li><li><strong>渲染进程（Renderer Process）</strong>：核心部分，负责将 HTML、CSS 和 JavaScript 转换成用户可以看到的网页。<strong>我们写的 JS 代码，主要就在这个进程的主线程（Main Thread）上运行</strong>。每个标签页通常会有一个独立的渲染进程。</li><li><strong>网络进程（Network Process）</strong>：负责处理网络请求，比如 <code>fetch</code>。</li><li><strong>GPU 进程（GPU Process）</strong>：负责处理 GPU 相关的任务，加速 3D 绘图和页面渲染。</li></ul></blockquote><p>这种设计的好处是隔离。一个标签页（渲染进程）崩溃了，不会影响到整个浏览器。</p><h2 id="任务队列-task-queue-和事件循环-event-loop" tabindex="-1"><strong>任务队列（Task Queue）和事件循环（Event Loop）</strong> <a class="header-anchor" href="#任务队列-task-queue-和事件循环-event-loop" aria-label="Permalink to &quot;**任务队列（Task Queue）和事件循环（Event Loop）**&quot;">​</a></h2><p>我们回到渲染进程的主线程。这个线程非常繁忙，它要做的事情包括：</p><ul><li>执行 JavaScript 代码</li><li>渲染页面布局（Layout）</li><li>绘制页面（Paint）</li><li>响应用户交互（Click, Scroll）</li></ul><p>如果所有任务都排队等着，一个耗时长的 JS 计算就会阻塞页面渲染和用户响应，这就是“假死”现象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一个会让页面卡住的例子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myButton&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 假装这是一个非常耗时的计算</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> start</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这5秒内，页面完全无法响应</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;计算完成!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>为了解决这个问题，浏览器引入了异步（asynchronous）执行模型。当遇到一些耗时操作（比如网络请求、定时器）时，主线程不会傻等，而是把这些任务“外包”给浏览器的其他线程（比如网络线程、定时器线程）。</p><p>这些“外包”任务完成后，会把一个“回调函数”（callback）放进一个叫做**任务队列（Task Queue）**的地方。主线程则继续执行自己手头的同步代码。</p><p>等到主线程的同步代码全部执行完毕，它就会去任务队列里看看，有没有需要执行的回调函数。如果有，就取出一个来执行。这个“<strong>主线程不断从任务队列里读取并执行任务</strong>”的过程，就叫做<strong>事件循环（Event Loop）</strong>。</p><p>这个模型可以用一张经典的图来表示：</p><p><img src="https://stack-mcell.tos-cn-shanghai.volces.com/019.jpg" alt="019.jpg" loading="lazy"></p><h2 id="微任务-microtask-和宏任务-macrotask" tabindex="-1"><strong>微任务（Microtask）和宏任务（Macrotask）</strong> <a class="header-anchor" href="#微任务-microtask-和宏任务-macrotask" aria-label="Permalink to &quot;**微任务（Microtask）和宏任务（Macrotask）**&quot;">​</a></h2><p>事情还没完。任务队列其实不止一个。根据 <a href="https://www.google.com/search?q=https://html.spec.whatwg.org/multipage/webappapis.html%23event-loops" target="_blank" rel="noreferrer">WHATWG 规范</a>，任务被分为两种类型：</p><ol><li><p><strong>宏任务（Macrotask，规范中称为 Task）</strong></p><ul><li><code>setTimeout</code>, <code>setInterval</code></li><li><code>script</code>（整体代码块）</li><li>I/O 操作, UI 渲染</li><li>用户交互事件（如 <code>click</code>, <code>scroll</code>）</li></ul></li><li><p><strong>微任务（Microtask）</strong></p><ul><li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code></li><li><code>queueMicrotask()</code></li><li><code>MutationObserver</code></li></ul></li></ol><p>事件循环的规则是，<strong>优先级更高的是微任务</strong>。主线程在执行完一个宏任务后，并不是立刻去执行下一个宏任务，而是会检查微任务队列。</p><p><strong>完整的事件循环流程如下：</strong></p><ol><li>从宏任务队列中取出一个任务（通常是 <code>script</code> 脚本本身）并执行。</li><li>执行完毕后，检查微任务队列。</li><li>循环执行微任务队列中的所有任务，直到队列清空。</li><li>执行浏览器 UI 渲染（这一步不一定每次都会发生）。</li><li>回到第一步，从宏任务队列中取出下一个任务。</li></ol><p>这个“<strong>执行一个宏任务 -&gt; 清空所有微任务 -&gt; 再取下一个宏任务</strong>”的循环，是理解所有异步执行顺序的关键。</p><h2 id="回到最初的问题" tabindex="-1"><strong>回到最初的问题</strong> <a class="header-anchor" href="#回到最初的问题" aria-label="Permalink to &quot;**回到最初的问题**&quot;">​</a></h2><p>现在，我们用这个模型来分析开头的代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;promise&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span></code></pre></div><ol><li><p><strong>第一轮宏任务（script 脚本）开始执行。</strong></p><ul><li>遇到 <code>console.log(&#39;start&#39;)</code>，直接执行。输出 <code>start</code>。</li><li>遇到 <code>setTimeout</code>，它是一个宏任务。浏览器定时器线程接管，0ms 后将其回调函数推入<strong>宏任务队列</strong>。</li><li>遇到 <code>Promise.resolve().then()</code>，<code>.then()</code> 的回调是一个微任务。它被推入<strong>微任务队列</strong>。</li><li>遇到 <code>console.log(&#39;end&#39;)</code>，直接执行。输出 <code>end</code>。</li></ul></li><li><p><strong>第一个宏任务（script）执行完毕。</strong></p><ul><li>现在，事件循环会检查<strong>微任务队列</strong>。发现里面有一个任务（打印 <code>promise</code>）。</li><li>取出并执行该微任务。输出 <code>promise</code>。</li><li>微任务队列现在空了。</li></ul></li><li><p><strong>开始下一轮宏任务。</strong></p><ul><li>事件循环检查<strong>宏任务队列</strong>，发现 <code>setTimeout</code> 的回调函数在那里。</li><li>取出并执行该宏任务。输出 <code>setTimeout</code>。</li></ul></li></ol><p>至此，所有代码执行完毕。最终输出 <code>start, end, promise, setTimeout</code>。</p><h2 id="应用与思考" tabindex="-1"><strong>应用与思考</strong> <a class="header-anchor" href="#应用与思考" aria-label="Permalink to &quot;**应用与思考**&quot;">​</a></h2><p>理解了事件循环，很多问题就迎刃而解了。</p><ul><li><p><strong><code>setTimeout(fn, 0)</code> 为什么不是立即执行？</strong> 因为它只是把 <code>fn</code> 尽快地推入宏任务队列，但必须等到当前主线程的同步代码和所有微任务都执行完之后，才有机会被执行。</p></li><li><p><strong>页面为什么会卡顿？</strong> 通常是因为一个宏任务（比如一段 JS 计算或一个事件回调）执行时间过长，导致主线程无法脱身去处理其他宏任务（如 UI 渲染、用户点击）。</p></li><li><p><strong>如何处理耗时计算？</strong> 对于真正 CPU 密集的计算，应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noreferrer">Web Worker</a>。它允许你在一个完全独立的后台线程中运行脚本，不会阻塞主线程。</p></li></ul><h2 id="参考链接" tabindex="-1"><strong>参考链接</strong> <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;**参考链接**&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noreferrer">MDN - Concurrency model and the event loop</a></li><li><a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0" target="_blank" rel="noreferrer">Jake Archibald: In The Loop - JSConf.Asia 2018</a>（非常经典的视频讲解）</li></ul><p>希望读完本文，你对 JavaScript 的运行机制有了更深入的理解。</p><p>（完）</p>`,45))])}const u=a(h,[["render",o]]);export{y as __pageData,u as default};
