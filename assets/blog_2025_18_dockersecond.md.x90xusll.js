import{_ as i,c as a,o as n,a9 as e}from"./chunks/framework.DsVI9alt.js";const c=JSON.parse('{"title":"Docker 进阶指南 - 容器管理与多服务编排实战","description":"Docker 进阶教程，深入学习容器生命周期管理、网络通信、数据持久化和 Docker Compose 多服务编排。通过实战案例掌握 Go 应用与 PostgreSQL 数据库的容器化部署和服务间通信。","frontmatter":{"title":"Docker 进阶指南 - 容器管理与多服务编排实战","description":"Docker 进阶教程，深入学习容器生命周期管理、网络通信、数据持久化和 Docker Compose 多服务编排。通过实战案例掌握 Go 应用与 PostgreSQL 数据库的容器化部署和服务间通信。","tags":["Docker","Docker Compose","容器管理","数据持久化","容器网络","PostgreSQL","Go","微服务","DevOps","容器编排"],"author":"mCell","head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/18_dockersecond"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/18_dockersecond"}]]},"headers":[],"relativePath":"blog/2025/18_dockersecond.md","filePath":"blog/2025/18_dockersecond.md","lastUpdated":1758819637000}'),p={name:"blog/2025/18_dockersecond.md"};function l(t,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[e(`<p><img src="https://stack-mcell.tos-cn-shanghai.volces.com/033.jpg" alt="033.jpg" loading="lazy"></p><h1 id="docker-进阶指南" tabindex="-1"><strong>Docker 进阶指南</strong> <a class="header-anchor" href="#docker-进阶指南" aria-label="Permalink to &quot;**Docker 进阶指南**&quot;">​</a></h1><p>在上一篇文章里，我们用 <code>docker build</code> 和 <code>docker run</code> 命令，成功地将一个应用放进了容器里并运行起来。这感觉很棒，就像 hello world 一样。</p><p>但是，hello world 之后，我们总会好奇背后的秘密。而且，只靠这两个命令，还远远无法应对真实的工作场景。你可能马上就会遇到一连串新的问题：</p><ul><li>容器在后台运行，我怎么知道它里面发生了什么？如何查看日志？</li><li>如果应用卡死了，或者我想暂时关闭它，该怎么操作？</li><li>我的应用不是孤立的，它需要连接数据库。数据库也放在容器里吗？两个容器如何“对话”？</li><li>每次启动应用都要敲一长串 <code>docker run</code> 命令，参数又多又难记，有没有更简单的方法？</li></ul><p>这些问题，才是我们日常工作的核心。今天，我们就来逐一攻克它们，让 Docker 从一个“有趣的玩具”变成我们手中“可靠的工具”。</p><h2 id="掌控容器-生命周期管理" tabindex="-1"><strong>掌控容器：生命周期管理</strong> <a class="header-anchor" href="#掌控容器-生命周期管理" aria-label="Permalink to &quot;**掌控容器：生命周期管理**&quot;">​</a></h2><p>首先，我们要学会如何管理一个正在运行的容器。</p><p>假设我们用上一篇的命令启动了一个 Go 服务器： <code>$ docker run -d -p 8080:8080 --name go-server go-hello-server:1.0</code></p><ol><li><p><strong>查看正在运行的容器</strong><code>docker ps</code> 命令会列出所有正在运行的容器，就像任务管理器一样。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ps</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CONTAINER</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ID</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   IMAGE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                 COMMAND</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  CREATED</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          STATUS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          PORTS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    NAMES</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f8b3a0c4a4e1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   go-hello-server:1.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   &quot;/app/main&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">              2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> minutes</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ago</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Up</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> minutes</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    0.0.0.0:8080</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">8080/tcp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   go-server</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里包含了容器 ID、所用镜像、运行状态、端口映射等关键信息。</p></li><li><p><strong>查看容器日志</strong> 应用在容器里运行，<code>fmt.Println</code> 或 <code>console.log</code> 的输出会去哪里？答案是 Docker 日志。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># docker logs [容器名或容器ID]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> logs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> starting</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> on</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> port</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 8080...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 加上 -f 参数，可以像 tail -f 一样持续跟踪日志</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> logs</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -f</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p><strong>停止、启动和重启容器</strong> 这就像操作服务一样简单。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 停止</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 再次启动</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> restart</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 重启</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>停止后，<code>docker ps</code> 就看不到它了，但容器并没有被删除。使用 <code>docker ps -a</code> 可以看到包括已停止在内的所有容器。</p></li><li><p><strong>进入容器内部</strong> 有时我们需要进入容器内部进行调试，比如查看文件、检查环境。<code>docker exec</code> 命令可以做到。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -it 参数让你可以在容器里进行交互式操作</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># /bin/sh 是我们想在容器里执行的命令，这里是启动一个 shell</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/sh</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 进入容器后，你就得到了一个 shell 提示符</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/app</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/app</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # exit</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li><li><p><strong>删除容器</strong> 如果一个容器你不再需要了，可以用 <code>docker rm</code> 删除它。注意，必须先停止容器才能删除。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> go-server</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol><p>现在，你已经掌握了容器的“生老病死”全过程管理，这是进行下一步的基础。</p><h2 id="连接容器-网络与数据" tabindex="-1"><strong>连接容器：网络与数据</strong> <a class="header-anchor" href="#连接容器-网络与数据" aria-label="Permalink to &quot;**连接容器：网络与数据**&quot;">​</a></h2><p>真实的应用很少是孤立的。一个 Go 后端服务，通常需要一个数据库（如 PostgreSQL），一个前端应用可能需要调用这个后端服务。</p><p><strong>1. 容器间的通信</strong></p><p>默认情况下，Docker 会创建一个名为 <code>bridge</code> 的虚拟网络。所有通过 <code>docker run</code> 启动的容器都会连接到这个网络上。<strong>在同一个网络内，容器之间可以通过容器名直接通信。</strong></p><p>让我们来验证一下。首先，我们启动一个 PostgreSQL 数据库容器：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-postgres</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> POSTGRES_PASSWORD=mysecretpassword</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  postgres:13</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>-e</code> 参数用来设置环境变量，这里是设置数据库的密码。</li></ul><p>现在，PostgreSQL 数据库正在名为 <code>my-postgres</code> 的容器中运行。你的 Go 应用如何连接它？</p><p>在你的 Go 代码里，数据库的连接地址<strong>不再是 <code>localhost</code></strong>，而应该是数据库容器的名称 <code>my-postgres</code>。</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 数据库连接字符串</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// host=localhost:5432  =&gt;  host=my-postgres:5432</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> connStr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;host=my-postgres user=postgres password=mysecretpassword dbname=postgres sslmode=disable&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Docker 内置了 DNS 服务，它会自动把容器名 <code>my-postgres</code> 解析成该容器的内部 IP 地址。这是 Docker 网络一个非常优雅的设计。</p><p><strong>2. 数据的持久化：数据卷 (Volume)</strong></p><p>我们刚刚启动的数据库容器，数据是保存在哪里的？答案是保存在容器内部的文件系统中。</p><p>这是一个巨大的隐患：<strong>如果容器被删除，数据就永远丢失了。</strong></p><p>为了解决这个问题，Docker 提供了<strong>数据卷（Volume）</strong>。你可以把数据卷想象成一个外接的 U 盘。我们将这个“U 盘”插到容器上，让应用把数据写到“U 盘”里。这样，即便容器这个“读卡器”坏了、被扔掉了，数据还在“U 盘”上，安然无恙。</p><p>使用数据卷非常简单，只需要在 <code>run</code> 命令里加一个 <code>-v</code> 参数。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 完整地启动一个带数据卷的 postgres 容器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> my-postgres</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> POSTGRES_PASSWORD=mysecretpassword</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -v</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pgdata:/var/lib/postgresql/data</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  postgres:13</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li><code>-v pgdata:/var/lib/postgresql/data</code> 的意思是： <ul><li>创建一个名为 <code>pgdata</code> 的数据卷（如果它不存在的话）。</li><li>将这个数据卷“挂载”到容器内部的 <code>/var/lib/postgresql/data</code> 目录上（这是 PostgreSQL 默认的数据存储路径）。</li></ul></li></ul><p>现在，所有数据库文件都会被写入 <code>pgdata</code> 这个数据卷里。你可以通过 <code>docker volume ls</code> 查看已有的数据卷。即使你删除了 <code>my-postgres</code> 容器，数据卷 <code>pgdata</code> 和里面的数据依然存在。</p><h2 id="docker-compose" tabindex="-1"><strong>Docker Compose</strong> <a class="header-anchor" href="#docker-compose" aria-label="Permalink to &quot;**Docker Compose**&quot;">​</a></h2><p>现在，我们有了 Go 应用和 PostgreSQL 数据库。每次启动它们，需要执行两条长长的 <code>docker run</code> 命令，还要注意启动顺序。如果服务更多，比如加上 Redis、Nginx，手动管理将成为一场噩梦。</p><p><code>Docker Compose</code> 就是来解决这个问题的。它是一个用于定义和运行多容器 Docker 应用程序的工具。你只需要在一个 YAML 文件中（默认为 <code>docker-compose.yml</code>），描述清楚你的应用由哪些服务构成，然后用一条命令就能同时启动或关闭所有服务。</p><p>在你的项目根目录下，创建一个 <code>docker-compose.yml</code> 文件：</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># docker-compose.yml</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 版本号</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.8&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 定义一系列服务</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 这是我们的 Go 后端服务</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 使用当前目录的 Dockerfile 来构建镜像</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;8080:8080&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 端口映射</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    depends_on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">db</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 表明 backend 服务依赖于 db 服务，Compose 会先启动 db</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 这是我们的数据库服务</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  db</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">postgres:13</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 直接使用官方镜像</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    environment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">      POSTGRES_PASSWORD</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">mysecretpassword</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">pgdata:/var/lib/postgresql/data</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 使用数据卷</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 定义数据卷</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">volumes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  pgdata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>这个文件清晰地定义了 <code>backend</code> 和 <code>db</code> 两个服务，以及它们之间的关系和配置。现在，管理整个应用只需要两条命令：</p><ul><li><p><strong>启动所有服务：</strong></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># -d 表示在后台运行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker-compose</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> up</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Compose 会自动构建镜像、创建网络、创建数据卷，并按依赖顺序启动所有容器。</p></li><li><p><strong>关闭并删除所有服务：</strong></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker-compose</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> down</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>它会帮你停止并删除所有相关的容器、网络。默认情况下，数据卷会被保留。</p></li></ul><p>有了 Docker Compose，复杂的应用环境变得前所未有地简单和清晰。</p><h2 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h2><p>至此，你掌握的 Docker 知识已经足以应对绝大部分的日常开发和测试工作。你会发现，无论是搭建开发环境、进行集成测试，还是确保团队成员环境一致，Docker 都将成为你的得力助手。</p><p>Docker 的世界依然广阔，下一步你可以去了解 Dockerfile 的最佳实践（比如多阶段构建），或者探索容器的终极舞台——Kubernetes。但无论走多远，今天所学的这些核心概念，都将是你坚实的基础。</p>`,41)]))}const g=i(p,[["render",l]]);export{c as __pageData,g as default};
