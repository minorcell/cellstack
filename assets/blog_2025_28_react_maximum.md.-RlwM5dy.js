import{_ as i,c as a,o as n,a9 as t}from"./chunks/framework.DsVI9alt.js";const E=JSON.parse('{"title":"React 如何处理高频的实时数据？","description":"深入解析 React 处理高频实时数据的技术方案，从 Maximum update depth exceeded 错误到批处理优化，完整解决 SSE 推送场景下的性能问题。","frontmatter":{"title":"React 如何处理高频的实时数据？","description":"深入解析 React 处理高频实时数据的技术方案，从 Maximum update depth exceeded 错误到批处理优化，完整解决 SSE 推送场景下的性能问题。","author":"mcell","tags":["React","性能优化","SSE","状态管理","实时数据","批处理","前端工程","JavaScript"],"keywords":["React高频更新","Maximum update depth exceeded","React批处理","SSE实时推送","React性能优化","useRef缓冲区","setTimeout批量处理","React状态管理","实时日志查看器","React嵌套更新"],"head":[["link",{"rel":"canonical","href":"https://stack.mcell.topblog/2025/28_react_maximum"}],["meta",{"property":"og:url","content":"https://stack.mcell.topblog/2025/28_react_maximum"}]]},"headers":[],"relativePath":"blog/2025/28_react_maximum.md","filePath":"blog/2025/28_react_maximum.md","lastUpdated":1763435064000}'),e={name:"blog/2025/28_react_maximum.md"};function p(h,s,l,k,d,r){return n(),a("div",null,s[0]||(s[0]=[t(`<p><img src="https://stack-mcell.tos-cn-shanghai.volces.com/069.png" alt="069.png" loading="lazy"></p><h1 id="react-如何处理高频的实时数据" tabindex="-1">React 如何处理高频的实时数据？ <a class="header-anchor" href="#react-如何处理高频的实时数据" aria-label="Permalink to &quot;React 如何处理高频的实时数据？&quot;">​</a></h1><p>最近，我遇到了一个很有意思的 React 问题。</p><p>我需要开发一个实时的日志查看器，功能上需要实时展示服务运行的日志。因为这个项目是内部的，我这里大概抽象一下：</p><p>后端使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events" target="_blank" rel="noreferrer">SSE（Server-Sent Events）</a> 技术，源源不断地把日志推送给前端。</p><p>当日志一条一条、不紧不慢地过来时，一切正常。</p><p>但是，当服务器在短时间内（比如 1 秒内）推送上百条日志时（比如查看历史日志的场景），网页卡顿了一下。浏览器控制台显示了一个 React 开发者很熟悉的错误：</p><blockquote><p><code>Uncaught Error: Maximum update depth exceeded...</code> (错误：超过最大更新深度)</p></blockquote><p>这个错误通常意味着，存在什么组件陷入了无限循环。比如，组件的渲染函数里直接调用了 <code>setState</code>，导致“渲染 → 更新状态 → 触发渲染 → ...”的死循环。</p><p>比如这样：</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Demo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Count: {count}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但我的代码并没有这样的逻辑，该使用 <code>useEffect</code> 的地方都使用了。我只是在 SSE 的事件回调里更新状态。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示意代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventSource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/api/logs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;log&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 每来一条日志，就调用 set 函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  appendLog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>那么，问题出在哪里呢？</p><h2 id="问题的根源-高频更新" tabindex="-1">问题的根源：高频更新 <a class="header-anchor" href="#问题的根源-高频更新" aria-label="Permalink to &quot;问题的根源：高频更新&quot;">​</a></h2><p>React 内部有一个“嵌套更新计数器”，用来防止无限循环。</p><p>简单说，如果在一次渲染（Render）的过程中，又因为某些原因触发了新的状态更新，这就叫“嵌套更新”。当这个次数短时间内超过一个阈值（通常是 50 次），React 就会认为你“可能”写了一个 Bug，于是主动抛出错误，终止程序。</p><p>我们的问题就出在这里。SSE 的事件回调来得太快了。</p><p>当服务器在 1 秒内推送 150 条日志时，浏览器的事件循环会疯狂执行回调：</p><ol><li>SSE 事件 1 抵达 → <code>appendLog()</code> → 触发 React 更新（第 1 次）</li><li>React 还没来得及渲染，SSE 事件 2 抵达 → <code>appendLog()</code> → 触发 React 更新（第 2 次）</li><li>...</li><li>SSE 事件 50 抵达 → <code>appendLog()</code> → 触发 React 更新（第 50 次）</li><li>SSE 事件 51 抵达 → <code>appendLog()</code> → 触发 React 更新（第 51 次）</li></ol><p>在 React 看来，这 51 次更新几乎是“同时”发生的，它无法分辨这是“51 条独立日志”还是“一个死循环”。为了保护自己，它选择了报错。</p><p><strong>问题的本质是：数据接收的频率（高频）和 React 状态更新的频率（低频）不匹配。</strong></p><p>我们不能每收到一条数据，就立刻更新一次状态。</p><h2 id="解决方案-批处理-batching" tabindex="-1">解决方案：批处理（Batching） <a class="header-anchor" href="#解决方案-批处理-batching" aria-label="Permalink to &quot;解决方案：批处理（Batching）&quot;">​</a></h2><p>既然不能一条一条地更新，那很自然就想到，能不能把日志“攒一下”，再一次性提交给 React？</p><p>这就是“批处理”（Batching）思想。</p><p>我们不再是“来一条，更新一次”，而是“来 N 条，更新一次”。</p><p>实现这个功能的关键，是需要一个“缓冲区”（Buffer）和一个“定时器”（Timer）。</p><ol><li><strong>缓冲区</strong>：需要一个地方暂存日志，但这个地方本身不能是 React 的 <code>state</code>（否则又触发渲染了）。<code>useRef</code> 是最合适的人选。</li><li><strong>定时器</strong>：需要一个机制，在“攒”日志的间隙，把它们统一提交。<code>setTimeout(..., 0)</code> 是这里的法宝。</li></ol><h2 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h2><p>我们来改造一下 <code>log</code> 事件的处理。</p><p>首先，在组件里定义缓冲区和定时器：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LogPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 1. 从 store 获取批量更新的方法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> appendLogs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useLogStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state.appendLogs)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2. 批处理缓冲区（使用 ref 不会触发渲染）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> batchBufferRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3. 定时器引用（保证只有一个定时器在运行）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> batchTimerRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useRef</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其次，实现一个“提交缓冲区”的函数 <code>flushBatch</code>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4. 批量提交函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> flushBatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果缓冲区有数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (batchBufferRef.current.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 一次性提交给 store</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    appendLogs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(batchBufferRef.current)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 清空缓冲区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    batchBufferRef.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 重置定时器引用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  batchTimerRef.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [appendLogs]) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 依赖 appendLogs</span></span></code></pre></div><p>最后，修改 SSE 的事件处理函数 <code>handleLogEvent</code>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 5. 新的 SSE 事件处理函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handleLogEvent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* ...解析日志... */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 重点：不再直接调用 appendLog</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 而是将日志加入缓冲区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    batchBufferRef.current.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entry)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果还没有计划批处理，则在下一个事件循环中执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (batchTimerRef.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      batchTimerRef.current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flushBatch, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [flushBatch] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 依赖 flushBatch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="为什么是-settimeout-0" tabindex="-1">为什么是 <code>setTimeout(..., 0)</code>？ <a class="header-anchor" href="#为什么是-settimeout-0" aria-label="Permalink to &quot;为什么是 \`setTimeout(..., 0)\`？&quot;">​</a></h2><p>你可能会问，为什么是 <code>setTimeout(..., 0)</code>？</p><p>这是一个很巧妙的技巧。它并不是真的“延迟 0 毫秒”，而是告诉浏览器：<strong>“请在当前这一轮事件循环（Event Loop）的同步代码都执行完之后，再执行这个 <code>flushBatch</code> 函数。”</strong></p><p>当 150 条日志在短时间内涌入时，会发生什么？</p><ol><li>事件 1 抵达 → <code>push</code> 到缓冲区 → <code>setTimeout</code> 注册一个 <code>flushBatch</code> 回调。</li><li>事件 2 抵达 → <code>push</code> 到缓冲区 → 检查定时器，发现已有，跳过。</li><li>事件 3 抵达 → <code>push</code> 到缓冲区 → 跳过。</li><li>...</li><li>事件 150 抵达 → <code>push</code> 到缓冲区 → 跳过。</li><li>（当前宏任务结束，所有同步代码执行完毕）</li><li>浏览器从任务队列中取出 <code>flushBatch</code> 回调，执行。</li><li><code>flushBatch</code> 函数将 150 条日志一次性提交给 React。</li></ol><p>于是，150 次 <code>setState</code> 调用，被神奇地合并成了 1 次。应用流畅如初。</p><p>（完）</p>`,44)]))}const g=i(e,[["render",p]]);export{E as __pageData,g as default};
